# 前端开发工程师工作流程和注意事项

前端开发工程师是负责网站和应用程序导航、布局和设计元素的工作人员，需要精通HTML、CSS和JavaScript等技术。以下是一些关于前端开发工程师工作流程和注意事项的信息：

#### 工作流程

前端开发工作流程一般包括需求分析、设计、开发、测试和部署等环节。具体流程如下：1. 需求分析：了解客户需求，确定网站或应用程序的功能和特点。

1. 设计：根据需求分析结果，设计网站或应用程序的页面布局、色彩、字体等。
2. 开发：根据设计稿，使用HTML、CSS、JavaScript等技术进行开发。
3. 测试：对网站或应用程序进行测试，确保其在不同浏览器和设备上的兼容性和稳定性。
4. 部署：将网站或应用程序部署到服务器上，使其能够被用户访问。

#### 注意事项

1. 技术要求：前端开发工程师需要掌握HTML、CSS、JavaScript等技术，同时需要了解一些常用的前端框架和库，如React、Vue等。
2. 团队合作：前端开发工程师需要与后端开发人员、设计师等多个团队成员进行协作，因此需要具备良好的沟通和团队合作能力。
3. 代码规范：前端开发工程师需要编写规范、易于维护的代码，遵循一些常用的代码规范和最佳实践。
4. 浏览器兼容性：前端开发工程师需要考虑不同浏览器和设备的兼容性，确保网站或应用程序在不同平台上都能正常运行。
5. 性能优化：前端开发工程师需要优化网站或应用程序的性能，提高其加载速度和响应速度，提升用户体验。

总之，前端开发工程师需要具备扎实的技术功底、良好的团队合作能力和编写规范、易于维护的代码的能力。同时，需要考虑浏览器兼容性和性能优化等问题，确保网站或应用程序的质量和用户体验。

# 什么是原型，什么是原型链 ?

## 1、什么是原型？

 原型prototype:这个属性对应着一个对象，这个对象就是原型对象。

## 2、什么是原型链？

当我们使用一个对象的属性或方法时，首先会在自身中寻找，

自身有，则直接使用；

自身没有则去原型对象中寻找，原型对象中有，则使用；

再没有则去原型的原型中寻找 ,这个过程就是原型链。

# HTTP状态码：StatusCode

一些常见的状态码为：

200 - 服务器成功返回网页
404 - 请求的网页不存在
503 - 服务不可用
详细分解：

1xx（临时响应）
表示临时响应并需要请求者继续执行操作的状态代码。

代码 说明
100 （继续） 请求者应当继续提出请求。 服务器返回此代码表示已收到请求的第一部分，正在等待其余部分。
101 （切换协议） 请求者已要求服务器切换协议，服务器已确认并准备切换。

2xx （成功）
表示成功处理了请求的状态代码。

代码 说明
200 （成功） 服务器已成功处理了请求。 通常，这表示服务器提供了请求的网页。
201 （已创建） 请求成功并且服务器创建了新的资源。
202 （已接受） 服务器已接受请求，但尚未处理。
203 （非授权信息） 服务器已成功处理了请求，但返回的信息可能来自另一来源。
204 （无内容） 服务器成功处理了请求，但没有返回任何内容。
205 （重置内容） 服务器成功处理了请求，但没有返回任何内容。
206 （部分内容） 服务器成功处理了部分 GET 请求。

3xx （重定向）
表示要完成请求，需要进一步操作。 通常，这些状态代码用来重定向。

代码 说明
300 （多种选择） 针对请求，服务器可执行多种操作。 服务器可根据请求者 (user agent) 选择一项操作，或提供操作列表供请求者选择。
301 （永久移动） 请求的网页已永久移动到新位置。 服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。
302 （临时移动） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。
303 （查看其他位置） 请求者应当对不同的位置使用单独的 GET 请求来检索响应时，服务器返回此代码。
304 （未修改） 自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。
305 （使用代理） 请求者只能使用代理访问请求的网页。 如果服务器返回此响应，还表示请求者应使用代理。
307 （临时重定向） 服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求。

4xx（请求错误）
这些状态代码表示请求可能出错，妨碍了服务器的处理。

代码 说明
400 （错误请求） 服务器不理解请求的语法。
401 （未授权） 请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。
403 （禁止） 服务器拒绝请求。
404 （未找到） 服务器找不到请求的网页。
405 （方法禁用） 禁用请求中指定的方法。
406 （不接受） 无法使用请求的内容特性响应请求的网页。
407 （需要代理授权） 此状态代码与 401（未授权）类似，但指定请求者应当授权使用代理。
408 （请求超时） 服务器等候请求时发生超时。
409 （冲突） 服务器在完成请求时发生冲突。 服务器必须在响应中包含有关冲突的信息。
410 （已删除） 如果请求的资源已永久删除，服务器就会返回此响应。
411 （需要有效长度） 服务器不接受不含有效内容长度标头字段的请求。
412 （未满足前提条件） 服务器未满足请求者在请求中设置的其中一个前提条件。
413 （请求实体过大） 服务器无法处理请求，因为请求实体过大，超出服务器的处理能力。
414 （请求的 URI 过长） 请求的 URI（通常为网址）过长，服务器无法处理。
415 （不支持的媒体类型） 请求的格式不受请求页面的支持。
416 （请求范围不符合要求） 如果页面无法提供请求的范围，则服务器会返回此状态代码。
417 （未满足期望值） 服务器未满足"期望"请求标头字段的要求。

5xx（服务器错误）
这些状态代码表示服务器在尝试处理请求时发生内部错误。 这些错误可能是服务器本身的错误，而不是请求出错。

代码 说明
500 （服务器内部错误） 服务器遇到错误，无法完成请求。
501 （尚未实施） 服务器不具备完成请求的功能。 例如，服务器无法识别请求方法时可能会返回此代码。
502 （错误网关） 服务器作为网关或代理，从上游服务器收到无效响应。
503 （服务不可用） 服务器目前无法使用（由于超载或停机维护）。 通常，这只是暂时状态。
504 （网关超时） 服务器作为网关或代理，但是没有及时从上游服务器收到请求。
505 （HTTP 版本不受支持） 服务器不支持请求中所用的 HTTP 协议版本。

# CDN加速

CDN 是内容分发网络 (Content Delivery Network) 的缩写，它是将数据分发到世界各地的节点服务器，使得用户能够就近获取所需内容，从而提高访问速度和用户体验。

CDN 加速原理：

1. CDN 有一批分布在不同地域的服务器节点，这些节点会缓存网站上的静态资源。
2. 用户在访问网站时，请求会优先到就近的 CDN 节点，从缓存的资源服务器上获取静态资源。
3. 如果该节点上没有资源，就会向源站服务器请求资源，缓存资源并传输到用户终端。
4. 若要请求的资源被缓存在了 CDN 节点上，则返回速度极快，从而提高用户访问体验。

CDN 加速的优点：

1. 提高网站的访问速度：由于 CDN 采用了最佳路由策略，使得用户能够就近获取所需内容，从而提高网站的访问速度。
2. 减轻源站服务器负载：由于静态资源被缓存在 CDN 节点上，用户请求这些静态资源时，减轻了源站服务器的压力，提高了网站的稳定性和可靠性，并且能够集中处理网站上的动态请求。
3. 节约带宽费用：由于 CDN 采用了内容复制和就近分发策略，用户请求的数据可以就近获取，减少了数据源和终端用户之间的传输距离，从而节约了带宽费用。
4. 提高访问量上限：由于 CDN 采用了缓存加速策略，提高了网站的访问速度，从而提高了网站的访问量上限。

总之，CDN 加速可以通过提高网站访问速度、减轻源站服务器负载、节约带宽费用等优势，提高网站的性能、稳定性和可靠性。

# 落地页

当访客访问时第一个见到的页面，在营销领域中，落地页通常是一个区别于你的官网或其他页面的独立页面。落地页的目的十分的单纯，那就是营销转化。落地页是实现你内容营销策略的承载工具。简单来说，落地页是帮助你将访客转化为顾客的高效工具。

# ping是什么？网络了解多少？

ping是计算机网络中的一种常见命令，用于测试计算机之间的连接性和网络延迟。具体来说，ping命令发送一个小数据包到目标主机，目标主机收到后会返回一个回复数据包，这样就可以通过计算这个过程的延迟和成功率来判断网络连接的好坏。ping命令可以用于诊断网络故障和测试网络速度。对于网络的了解，可以更全面地掌握计算机和应用之间的数据传输过程，有助于诊断和解决网络问题。

# indexDB简介

indexDB是一种底层API，用于在客户端存储大量的结构化数据（也包括文件/二进制大型对象（blobs））。该API使用索引实现对数据的高性能搜索。虽然Web Storage在存储较少量的数据很有用，但对于存储更大量的结构化数据来说力不从心。而indexDB提供了这种场景的解决方案。

客户端各存储方式对比：

![img](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/6b50dd9b052e4dde934c217fa1c1ca01~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp)

## 特点

1、indexDB是现代浏览器提供的一种客户端存储技术，用于在本地存储数据，可以存储大量的结构化数据。

2、indexDB采用对象数据库模型，数据以对象的形式组织存储。数据以数据库的形式存储，可以创建多个数据库。 每个数据库可以有多个存储空间（Object Store）,每个存储空间可以存储一个类型的对象。

3、indexDB是事务性的，每一次数据的读写都在事务的保护下进行，保证数据的完整性和一致性。indexDB还支持游标（Cursor）的游历方式，方便数据的逐一遍历。

4、indexDB使用异步API，防止操作阻塞和界面卡顿。

5、indexDB支持复杂的查询操作，可以使用索引来查询数据。

6、indexDB默认采用同源策略，存储的数据只能被同源（Origin）访问。

## indexDB的使用方式

1、打开数据库：使用indexDB.open()方式打开数据库，可以指定数据库名称和版本等信息。

2、新建存储空间：打开数据库后，可以通过 `db.createObjectStore()`方式来新建存储空间。可以指定存储空间名称和键路径等信息。

3、存储数据：使用事务进行数据的添加、修改和删除等操作，可以使用 `add()`、`put()`和 `delete()`方式来进行操作。

4、查询数据：可以使用索引和游标的方式查询数据。

5、关闭数据库：使用 `db.close()`方式来关闭数据库连接。

# **跨域请求有哪几种解决方式？哪种方式最好？**

跨域请求指的是浏览器限制页面的脚本只能向同一源（协议、域名。端口）发出HTTP请求的安全限制。为了解决跨域问题，常用的解决方案有以下几种：

1、JSONP：利用script标签没有跨域限制的特性，将需要请求的数据作为JS代码执行，并利用回调函数返回数据。

2、CORS（Cross-Origin Resource Sharing）:使用CORS协议，使用服务器端设置Access-Control-Allow-Origin等响应头信息。

3、代理：同一域下部署代理服务器，然后将跨域请求发送到代理服务器中。代理服务器再将请求发送到目标服务器，获得响应后再将响应返回前端。代理方式可以解决前端跨域请求的问题，但会增加服务器的负担并且会增加请求的延迟。

4、WebSocket：WebSocket协议不受同源策略限制，客户端与服务器建立一个长连接，然后通过该连接进行双向通信。使用WebSocket可以实现跨域请求。

5、postMessage：HTML5增加了一种消息传递的方式，称为跨文档消息postMessage。可以在父窗口和子窗口之间传递数据，可以用于跨域通信。

**不同的方式适合不同的场景，没有最好的解决方式，需要根据实际情况进行选择。通常来说，现在的应用多使用CORS，因为CORS是一种浏览器原生支持的跨域解决方案，而且安全可靠，对HTTP请求和响应的头部信息都进行了规范。**

# **怎么用from携带请求数据？**

可以使用from表单来携带请求数据。

在HTML中，使用from和input元素组合成表单来获取和提交数据。在表单使用method属性指定请求方式，一般为GET或POST。使用name属性给input元素命名，然后在后端接受请求时使用这些名称来获取参数。

在使用POST方式提交表单时，请求的数据会被放在请求体中，可以使用form表单中的enctype属性来设置提交数据的编码类型。常见的编码类型有 `application/x-www-form-urlencoded`、`multipart/form-data`等。

下面是一个使用from表单携带请求数据的实例:

```html
<form action="/register" method="POST">
    <label>用户名：</label>
    <input type="text" name="username" />
    <br>
    <label>密码：</label>
    <input type="password" name="password" />
    <br>
    <input type="submit" value="提交" />
</form>
```

在这里，使用form表单提交用户的注册信息，表单的method属性被设置为POST，将会把用户填写的数据以POST方式提交给服务器。每个input元素都有一个name属性，表示要提交的数据项的名称，例如“username”和“password”。

在服务器端，可以使用不同的语言来接收这些请求参数，并对其进行处理。比如可以在后端使用JavaScript的Express框架接收请求参数。

```js
const express = require('express');
const app = express();
app.use(express.urlencoded({extened:true}));
app.post('/register', function(req, res){
	const username = req.body.username;
   	const password = req.body.password;
   	// do something
}
```

# ES6新特性

ES6（ECMAScript 2015）是JavaScript的一个标准，它引入了许多新特性，以下是一些新特性：

1、块级作用域变量（let和const）

2、箭头函数

3、Class语法糖

4、模版字符串

5、解构赋值

6、默认参数

7、Rest参数

8、Spread操作符

9、Promise对象

10、Async/Await函数

11、Set和Map数据结构

12、Symbol类型

13、for-of循环

14、简洁属性和方法名

15、模块化（import和export）

这些新特性大大提高了JavaScript的语法性能和表现力，使开发者能够更有效地编写代码。

# 实现居中的方式有哪些

1、对于定宽元素，使用 `margin：0 auto`将 左右margin设为自动，实现水平居中。

2、对于不定宽元素，可以采用flex布局（在父容器上设置 `display：flex`），并设置 `justify-content：center `和 `align-items：center`实现水平垂直居中。

3、对于需要脱离文档流的元素，可以使用position和transform实现垂直居中，例如：

```css
.parent{
position:relative;
}
.child{
position:absolute;
top:50%;
transform:translateY(-50%);
}
```

4、对于文字居中，可以使用 `text-aligin：center`实现水平居中。

需要注意的是，实现居中也要根据实际情况选择最合适的方法。例如图片、文本、表格等元素之间需要水平居中时，可以采用 `inline-block`方式实现。而当元素需要相对父容器居中时，可以使用垂直居中的方法。

# 如何阻止事件冒泡与默认行为

在JavaScript中，我们可以使用 `event.stopPropagation()`方法来阻止事件冒泡，使用 `event.preventDefault()`方法来阻止事件默认行为。

## 1、阻止事件冒泡

当事件触发时，他会以事件冒泡的方式向父元素传递，直到传递到文档根节点。在某些情况下，我们需要停止事件冒泡，以防止它继续传递到父元素上。可以使用 `event.stopPropagation()`方式来停止事件冒泡。

实例代码：

```javascript
document.querySelector('#child').addEventListener('click', function (event) {
  alert('Child clicked!');
  event.stopPropagation();
});

document.querySelector('#parent').addEventListener('click', function (event) {
  alert('Parent clicked!');
});
```

在上述代码中，当我们点击子元素时，会触发子元素的click事件，并且弹出“Child clicked！”的提示框，但不会再次触发父元素的click事件，因为我们使用了 `event.stopPropagation()`方法停止了事件冒泡。

## 2、阻止事件的默认行为

某些事件会触发默认行为，例如点击链接会跳转到对应的UPL地址，按下回车键会提交表单等。在某些情况下，我们需要禁止事件的默认行为，可以使用 `event.preventDefault()`方式来实现。

实例代码：

```javascript
document.querySelector('#link').addEventListener('click', function (event) {
  event.preventDefault();
  console.log('Link clicked!');
});
```

在上述代码中，当我们点击链接时，会触发链接的默认行为（跳转到对应的URL地址）。但由于我们使用了 `event.preventDefault()`方法，所以链接的默认行为会被禁止了，同时也会在控制台输出“Link clicked！”的信息。

需要注意的是，`event.stopPropagation()`和 `event.preventDefault()`可能会对事件处理产生影响，因此需要谨慎使用。在具体应用时，需要结合实际场景和需求进行选择和使用。

# JavaScript中对象的创建方式有哪些

1、对象字面量：使用对象字面量可以创建一个简单的对象，这是一个常见的方式。

2、构造函数：使用构造函数可以创建一个对象，这个对象可以具有自己的属性和方法。

3、Object.create()方法：使用Object.create()方法可以创建一个新对象，该对象的原型是指定的对象。

4、工厂模式：使用工厂模式可以创建一个对象，这个对象可以具有自己的属性和方法。

5、原型模式：使用原型模式可以创造一个对象，该对象的属性和方法是从原型对象继承而来的。

6、组合使用构造函数模式和原型模式：使用这个方法可以创建一个对象，该对象具有自己的属性和方法，并且可以从原型对象继承属性和方法。

7、寄生构造函数模式：是用寄生构造函数模式可以创造一个对象，该对象具有自己的属性和方法，并且可以从原型对象继承属性和方法。

总之，JavaScript中创建对象的方法有很多种，包括对象字面量、构造函数、Object.create()方法、工厂模式、原型模式、组合使用构造函数模式和原型模式、寄生构造函数模式等。每种方式都具有其优缺点，需要根据具体情况来选择。

# 简述Vue组件中computed与methods的区别

在Vue组件中，computed和methods都是用来处理数据的方法，但是他们之间有以下区别：

1、computed是带缓存的，只有依赖数据发生改变，才会重新进行计算，否则直接但会之前的计算结果，而methods里的函数在每次调用时候都要执行。

2、computed是响应式的，而methods不是响应式的。

3、调用方式不同，computed定义的成员是像属性一样访问的，而methods定义的成员必须以函数形式调用的。

4、computed中的成员可以定义为只读属性，也可以定义为可读属性，而methods的成员只能定义为函数。

总之，computed和methods都是用来处理数据的方式，但是他们之间有一些区别。computed是带有缓存的、响应式的，调用方式像属性一样访问，而methods则不带缓存、不响应式，调用方法必须是以函数形式调用。子啊使用是需要根据具体情况来选择使用哪种方法。

# react中的Hooks

Hooks是React16.8版本中引入的一种新特性，他们允许函数组件具有状态和其他React特性。Hooks解决了类组件的一些问题，如包装器过多、组件过大和类的混乱。Hooks赋予了React函数组件的能力，使得可以使用函数组件开发整个应用程序。React提功了一些内置的Hooks，如useState、useEffect、useContext、useReducer等，开发人员也可以创建自己的Hooks捞重用状态行为。Hooks不会取代已存在的React概念和类，它们只是提供了一个API来访问它们。Hooks有一些规则，如只能在React函数组件中调用、只能在组件的顶层调用、不能在条件语句、循环或嵌套函数中调用等。总之，Hooks是React中一种强大的特性，可以使函数组件具有状态和其他React特性，从而使React应用程序更加灵活和易于开发。

# react事件绑定this的写法

1、在构造函数中使用bind绑定this：在构造函数中使用bind方法将this绑定到当前组件中。这种方法可以确保在事件处理程序中this指向组件实例。

2、在调用的时候使用bind绑定this：在事件处理程序中使用bind方法将this绑定到当前组件中。这种方法可以确保在事件处理程序中this指向组件实例。

3、在调用的时候使用箭头函数绑定this：在事件处理程序中使用箭头函数将this绑定到当前组件中。这种方法可以确保在事件处理程序中this指向组件实例。

4、使用属性初始化器语法绑定this：使用属性初始化器语法可以在类中直接定义箭头函数，从而将this绑定到当前组件中。这种方法可以确保在事件处理程序中this指向组件实例。

总之，React事件绑定中this的写法有多种，包括在构造函数中使用bind绑定this、在调用的时候bind绑定this、在调用的时候使用箭头函数绑定this以及使用属性初始化器语法绑定this等。这些方法都可以确保在事件处理程序中this指向组件实例，开发人员可以根据具体情况选择使用选择哪种方法。

# 纯函数

纯函数是指在相同的输入下，总是返回相同的输出，而且没有任何副作用的函数。副作用是指函数在执行时，会对函数外部的状态造成影响，例如修改全局变量或者修改传递给函数的参数。纯函数的好处包括更容易进行测试，更容易维护和重构，更容易调用，因为不用担心函数的副作用。纯函数是函数式编程的基础，多写纯函数可以写出质量更高的代码。在JavaScript中，纯函数和非纯函数的区别在于，纯函数不会修改传递给它的参数，也不会修改全局变量，而非纯函数则可能会有这些副作用。全纯函数是复分析研究的中心对象，它们是定义在复平面上的函数，满足某些特定的条件，例如可导或解析。全纯函数有时称为正则函数，在整个复平面上都全纯的函数称为整函数。

# **h5新增特性**

HTML5是HTML的最新版修订版本，引入了许多新特性，一下是一些常见的新增特性：

1、语义化标签：HTML5新增了许多语义化标签，如hrader、nav、footer、main、article、section等，使得代码结构更清晰，提高了代码可读性。

2、视频和音频：HTML5新增了video和audio标签，可以在网页中嵌入浏览器的音频是视频内容，而不需要依赖任何插件。

3、canvas绘图（画布）：HTML5新增了canvas元素，可以在页面中动态绘制图形，实现更加丰富的交互效果。

4、svg绘图：HTML5新增了SVG元素，可以在页面中使用矢量图标，实现更加丰富的图形效果。

5、增强型表单：HTML5新增了许多表单元素和属性，如color、date、datetime、email、number、range、search、tel、time、url等、可以改善输入控制和验证。

6、地理定位：HTML5新增了Geolocation API，可以获取用户的地理位置信息，实现更加精确的定位服务。

7、拖放API：HTML5新增拖放API，可以实现拖拽释放功能，提高了用户体验。

8、WebWorker：HTML5新增了WebWorker API，可以在后台线程中执行JavaScript代码，提高了应用程序的性能。

9、WebStorage：HTML5新增了WebStorage API ，可以再浏览器中村粗数据，实现更加高效的数据管理。

总之，HTML5引入了许多新特性，如语义化标签、视频和音频、Canvas绘图、SVG绘图、增强型表单，地理定位、拖放API、WebWorker和WebStorage等，这些特性可以提高网页的交互性、可读性、可维护性和性能。

# 为什么0.1+0.2不等于0.3

在JavaScript中，0.1+0.2不等于0.3的原因是因为浮点数的精度原因。由于计算机使用二进制来表示浮点数，而二进制无法精确表示某些十进制小数，因此子啊进行浮点计算时会出现精度误差。这种误差可能导致0.1+0.2的结果略大于0.3，例如0.30000000000000004。这个问题不仅勋在于JavaScript中，也存在于其他编程语言中。为了解决这个问题，可以使用一些小技巧，如将浮点数转换为整数进行计算，或者使用特殊的来解决浮点精度问题。总之，由于浮点精度问题，0.1+0.2不等于0.3，这是计算机科学中的一个普遍问题

# **闭包的理解**

闭包是指一个函数可以访问领一个函数内部的变量和参数，即使那个函数已经执行完毕并返回了。闭包可以理解为一个函数和它的词法环境的组合体，词法环境包括了函数定义是的作用域链。当函数执行完毕后，其执行上下文会被销毁，但是由于闭包的存在，函数内部的变量和参数仍然可以被访问。闭包可以用来创建私有变量和方法，以及实现模块化编程。在JavaScript中，闭包的应用非常广泛，例如在事件处理程序中、在定时器中、在毁掉函数中等等。需要注意的是，由于闭包会占用内存，因此在使用闭包时需要逐一内存泄漏的问题。总之，闭包是JavaScript中一个非常重要的概念，可以用来实现许多高级的编程技巧。

# **node的理解**

Node.js是一个基于Chrome V8引擎的JavaScript运行时环境，可以让JavaScript在服务器端运行。Node.js才用了事件驱动、非阻塞I/O模型，可以处理大量并发连接，提高了服务器的性能和可扩展性。Node.js的优点包括高性能、高并发、易于学习、跨平台、丰富的模块库等。Node.js的应用场景包括Web应用程序、命令行工具。网络爬虫、物联网、实时通讯等。Node.js的缺点包括不适合CPU密集型任务、单线程模型可能导致阻塞、模块库的质量参差不齐等。总之，Node.js是一个非常强大的JavaScript运行时环境，可以让JavaScript在服务器运行，提高了服务器的性能和可扩展性，具有广泛的应用场景。

# I/O模型详解

I/O模型是指计算机在进行输入输出操作时所采用的方式。常用的I/O模型有阻塞I/O、非阻塞I/O、I/O复用、信号驱动I/O和异步I/O等。其中阻塞I/O时最传统的一种模型，指在读写数据过程中会发生阻塞现象，即当用户线程发起一个I/O操作后，需要等待内核I/O曹组完成后才能继续执行。非阻塞I/O则是指当用户线程发起一个I/O操作后，并不需要等待，而是马上就返回一个状态值，告诉用户线程I/O操作是否完成。I/O复用是指通过select、poll、epoll等系统调用，将多个I/O操作复用在同一个线程中从而提高了系统的并发性能。信号驱动I/O是指当I/O操作完成后，内核会向用户线程发送一个信号，告诉它I/O操作已经完成，用户线程可以进行下一步操作。异步I/O则是指用户线程发送一个I/O操作后，不需要等待I/O操作完成，而是可以继续其他操作，当I/O操作完成后，内核会通知用户线程。总之。I/O模型是计算机进行输入输出操作时所采用的方式，不同的I/O模型有不同的优缺点，需要根据具体情况来选择使用哪种模型。

# 前后端联调

前后端联调是指前端和后端开发人员在开发过程中，通过接口进行数据交互和调试的过程。以下是一些前后端联调的建议：

* 接口文档：前后端开发人员需要共同编写接口文档，明确接口的请求方式、参数、返回值等信息，以方便双向足够正确地理解和使用接口。
* 接口mock：在开发过程中，可以使用接口mock模拟假数据，以方便进行测试和测试。
* 字段名保持一致：前后端开发人员应保持字段名一致，以方便前端理解和开发。
* 协商确定数据接口：在前后端开发人员碰面之后，协商确定好之前需要的数据接口，然后前后端程序员就可以并发了。
* 自动化构建工具：在联合调过程中，可以使用自动化构建工具来进行数据交换，以提高开发效率

  总而言之，前后端联调是一个非常重要的开发环，需要前后端开发人员密切合作，确保数据交互的正确性和稳定性定性。

# scss与less中如何定义变量

在SCSS中，可以使用 `$ `符号来定义变量，如下所示：

```scss
$primary-color: #ff0000;
$font-size: 14px;

h1 {
  color: $primary-color;
  font-size: $font-size;
}
```

在上述代码中，我们定义了两个变量 `$primary-color`和 `$font-size`，分别表示主色调和字体大小。在 `h1`选择器的属性中，使用 `$primary-color`和 `$font-size`变量来设置颜色和字体大小，可以有效地避免样式代码的重复。

在LESS中，可以使用 `@`符号来定义变量，如下所示：

```less
@primary-color: #ff0000;
@font-size: 14px;

h1 {
  color: @primary-color;
  font-size: @font-size;
}
```

在上述代码中，同样定义了两个变量 `@primary-color`和 `@font-size`，使用 `@primary-color`和 `@font-size`变量来设置颜色和字体大小，实现了样式的复用。

综上所述，SCSS和LESS中的变量定义方式类似，具体选择使用哪种预处理器，取决于团队的选择和个人习惯。

# 写一个递归函数，实现某个数字阶乘的运算，如：5！=5 * 4 * 3 * 2 * 1

这是一个递归函数，用于计算一个数字的阶乘：

```javascript
function factorial(n) {
  if (n === 0) {
    return 1;
  } else {
    return n * factorial(n - 1);
  }
}
```

这个函数首先检查输入的数字是否为0。如果是0，它返回1，因为0的阶乘为1。否则，它返回输入数字乘以比它小1的数字的阶乘。这个过程一直持续到输入数字为1，然后递归停止。例如，如果我们调用函数 `factorial(5)`，它将返回5⋅4⋅3⋅2⋅1=120，这是5的阶乘。

# vuex中如何变更转态数据（同步与异步）

在Vuex中，可以使用mutations来同步地变更数据，也可以使用actions来异步地变更状态数据。mutations是用来变更状态的异步函数。在mutations中，可以直接修改转态数据，而在actions中，需要通过commit mutatins来修改状态数据。下面是一个简单的实例：

```javascript
//定义状态
const state = {
	count: 0 
}

//定义mutations
const mutations = {
	increment(state) {
	  state.count++
  }
}

//定义actions
const mutations = {
  incrementAsyno({ commit }) {
	setTimeout(() => {
	  commit('increment')
    },1000)
  }
}
```

在上面的示例中，我们定义了一个状态 `count`，一个mutation `increment`和一个异步函数，通过 `commit`。`incrementAsync`是一个异步函数，通过 `commit`来调用 `increment`来修理状态数据。这样，我们就可以在组件中通过dispatch来调用 `incrementAsync`来异步地变更状态数据了。

# 组件中如何调用到Vuex的store中的mutation、action方法

要在组件中调用Vuex的store中的mutation和action方法，可以使用以下方法：

1. 在组件中使用 `this.$store.commit('mutationName')`来调用mutation方法，其中 `mutationName`是mutation的名称。如果mutation需要传递参数，则可以使用 `this.$store.commit('mutationName', payload)`来传递参数。
2. 在组件中使用 `this.$store.dispatch('actionName')`来调用action方法，其中 `actionName`是action的名称。如果action需要传递参数，则可以使用 `this.$store.dispatch('actionName', payload)`来传递参数。
3. 使用 `mapMutations`和 `mapActions`辅助函数来简化代码。这些辅助函数可以将组件中的methods映射为store.commit和store.dispatch调用。例如，可以使用 `mapMutations(['mutationName'])`将 `mutationName`映射为组件中的方法，然后在组件中直接调用 `this.mutationName()`来调用mutation方法。

   下面是一个简单的示例：

   ```javascript
   // 定义状态
   const state = {
     count: 0
   }

   // 定义mutations
   const mutations = {
     increment(state) {
       state.count++
     }
   }

   // 定义actions
   const actions = {
     incrementAsync({ commit }) {
       setTimeout(() => {
         commit('increment')
       }, 1000)
     }
   }

   // 在组件中使用mutation和action
   <template>
     <div>
       <p>{{ count }}</p>
       <button @click="increment">Increment</button>
       <button @click="incrementAsync">Increment Async</button>
     </div>
   </template>

   <script>
   import { mapState, mapMutations, mapActions } from 'vuex'

   export default {
     computed: {
       ...mapState(['count'])
     },
     methods: {
       ...mapMutations(['increment']),
       ...mapActions(['incrementAsync'])
     }
   }
   </script>
   ```

在上面的示例中，我们使用了 `mapState`来映射状态 `count`，使用 `mapMutations`来映射mutation `increment`，使用 `mapActions`来映射action `incrementAsync`。然后在组件中，我们可以直接使用 `this.count`来获取状态数据，使用 `this.increment()`来调用mutation方法，使用 `this.incrementAsync()`来调用action方法。

# Vue2.x中filter的作用是什么，何如定义？

过滤器（filter）是Vue中的一个特性，用于对文本进行格式化的作用。在Vue2.x中，过滤器允许自定义过滤器，可被用于一些常用的文本格式化。过滤器可以用在两个地方：双花括号插值和v-bind表达式。过滤器本质上是一个函数，可以在Vue实例的选项中定义，或者使用全局方法Vue.filter()注册一个自定义过滤器。过滤器的定义方法如下：

```javascript
Vue.filter('filterName',function(value){
	//过滤器的处理逻辑
	return processedValue;
})
```

其中，`filterName`是过滤器的名称，function(value)是过滤器的处理函数，value是需要处理的值，processedValue是处理后的值。


# 导航解析流程

1、导航被触发。

2、在失活的组件里调用 `beforeRouteLeave`守卫。

3、调用全局的 `beforeEach守卫。`

4、在重用的组件里调用 `beforeRouterUpdate`守卫（2.2+）

5、在路由配置里调用 `beforeEnter`。

6、解析异步路由组件。

7、在被激活的组件里调用 `beforrRouteEnter`。

8、调用全局的 `beforeResolve`守卫（2.5+）。

9、导航被确认。

10、调用全局的 `afterEach`钩子。

11、触发DOM更新

12、调用 `beforeRouteEnter`守卫中传给 `next`的回调函数，创建好的组件实例会作为回调函数的参数传入。
